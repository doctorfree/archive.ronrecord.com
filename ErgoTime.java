/*****************************************************************Copyright (c) 1995-96 Michael Olivier and Silicon Graphics, Inc.Permission to use, copy, modify, and distribute this software and itsdocumentation for any not-for-profit purpose is hereby granted withoutfee, provided that the above copyright notice appears in all copies andthat both the copyright notice and this permission notice appear insupporting documentation, and that the name of Silicon Graphics, Inc.not be used in advertising or publicity pertaining to distribution ofthe software without specific, written prior permission.THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANYWARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.IN NO EVENT SHALL MICHAEL OLIVIER OR SILICON GRAPHICS BE LIABLE FOR ANYSPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, ORANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORYOF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE ORPERFORMANCE OF THIS SOFTWARE.******************************************************************ErgoTime - ergonomically correct approximate time of day, 	   as a string.Original idea from an old Apollo Systems Unix ErgoClock.Revision History:mvo	12/95		first versionmvo	2/17/96		declared Version 0.9*****************************************************************/ import java.util.Date;public class ErgoTime{    String hoursStrs[] =     {	"midnight", "one", "two", "three", "four", "five", "six", 	"seven", "eight", "nine", "ten", "eleven"    };    // 7 values - nothing over 30, because we switch to inverted    // "twenty-five till" format...    String fiveMinStrs[] =     {	"", "five", "ten", "quarter", "twenty", "twenty-five", "half"    };        String approxMinStrs[] =     {	"", "just after", "a bit after", "not quite", "almost"    };    String timeStr;        public void init()     {	timeStr = new String();	update();    }    public String update()    {	StringBuffer sb = new StringBuffer();	Date today = new Date();		// handle midnight and noon specially	if (today.getMinutes() == 0 && (today.getHours() % 12) == 0)	{	    if (today.getHours() == 0)		sb.append("Midnight");	    else		sb.append("Noon");	}	else	{	    getStandardTime(today, sb);	}	// capitalize first word in the phrase	sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));		timeStr = sb.toString();	return timeStr;    }    public String getString()    {	return timeStr;    }        private void getStandardTime(Date today, StringBuffer sb)    {	// first build up standard string, like "ten past eight", 	// or "twenty-five till nine", and then add modifiers to it	int mins = today.getMinutes();	// anything past 32 mins is reversed -- e.g., twenty till seven.	// We wait till > 32 because we want 31 and 32 to read as "just	// after half past eight", for instance.	// XXX couldn't figure out how to create and use Booleans	int inverted = 0;	if (mins > 32)	{	    inverted = 1;	    mins = 60 - mins;	}	int roundedMins = ((mins+2)/5) * 5;	if (roundedMins > 30)	{	    System.out.println("ERROR - rounded mins > 30 in getStandard()\n");	    roundedMins = 30;	}	if (roundedMins != 0)	{	    sb.append(fiveMinStrs[roundedMins/5]);	    if (inverted != 0)		sb.append(" till ");	    else		sb.append(" past ");	}		int hrs = today.getHours();	if (inverted != 0) ++hrs;	// midnight is in hoursStrs[] array but noon isn't...	if (hrs == 12)	    sb.append("noon");	else	    sb.append(hoursStrs[hrs % 12]);	// build the approx part, such as "just after"	// ... reverse logic if inverted...	int index = mins % 5;	if (inverted != 0) index = (5 - index) % 5;	if (approxMinStrs[index].length() != 0)	    sb.insert(0, approxMinStrs[index] + " ");		// add an O'Clock at the top of the hour	if (today.getMinutes() == 0 && (today.getHours() % 12) != 0)	    sb.append(" O'Clock");    }}